<resources>
    <string name="app_name">Cpu Scheduling Simulator</string>
    <string name="title_cpu_scheduling">CPU Scheduling</string>
    <string-array name="algorithm_select">
        <item>FCFS</item>
        <item>SJF (Non Preemptive)</item>
        <item>Priority (Non Preemptive)</item>
        <item>Round Robin</item>
    </string-array>


    <string name="p">P</string>
    <string name="emptyValues">Empty Values</string>
    <string name="enterAllValues">Please enter all values</string>
    <string name="okay">Okay</string>
    <string name="ms">ms</string>
    <string name="processText">Process :</string>
    <string name="addProcessText">Next Process</string>
    <string name="arrivalTimeInMs">Arrival time(ms)</string>
    <string name="burstTimeInMs">Burst time(ms)</string>
    <string name="one">1</string>
    <string name="priority">Priority</string>
    <string name="timeQuantum">Time Quantum(Q)</string>
    <string name="simulate">Simulate</string>
    <string name="reset">Reset</string>

    <string name="cpuFragment">CPU Fragment</string>
    <string name="memoryFragment">Memory Fragment</string>


    <string name="Info">First Come First Serve Scheduling</string>
    <string name="Info_fcfs">In the "First come first serve" scheduling algorithm, as the name suggests, the process which arrives first, gets executed first, or we can say that the process which requests the CPU first, gets the CPU allocated first.\n\n First Come First Serve, is just like FIFO(First in First out) Queue data structure, where the data element which is added to the queue first, is the one who leaves the queue first.\n\n This is used in Batch Systems.\n\n It is easy to understand and implement programmatically, using a Queue data structure, where a new process enters through the tail of the queue, and the scheduler selects process from the head of the queue.\n\n A perfect real life example of FCFS scheduling is buying tickets at ticket counter.\n\n</string>

    <string name="Info_sjf">Shortest job first (SJF) or shortest job next, is a scheduling policy that selects the waiting process with the smallest execution time to execute next. SJN is a non-preemptive algorithm.\n

Shortest Job first has the advantage of having minimum average waiting time among all scheduling algorithms.\n
It is a Greedy Algorithm.\n
It may cause starvation if shorter processes keep coming. This problem can be solved using the concept of aging.\n
It is practically infeasible as Operating System may not know burst time and therefore may not sort them. While it is not possible to predict execution time, several methods can be used to estimate the execution time for a job, such as a weighted average of previous execution times. SJF can be used in specialized environments where accurate estimates of running time are available.\n
    </string>

    <string name="Info_priority">Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems. Each process is assigned a priority. Process with the highest priority is to be executed first and so on.\n
Processes with the same priority are executed on first come first served basis. Priority can be decided based on memory requirements, time requirements or any other resource requirement.\n

    </string>
    <string name="Info_RR">Round Robin is a CPU scheduling algorithm where each process is assigned a fixed time slot in a cyclic way.\n

It is simple, easy to implement, and starvation-free as all processes get fair share of CPU.\n
One of the most commonly used technique in CPU scheduling as a core.\n
It is preemptive as processes are assigned CPU only for a fixed slice of time at most.\n
The disadvantage of it is more overhead of context switching.\n</string>
</resources>
